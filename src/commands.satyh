@require: base/length
@require: base/inline
@require: base/list-ext
@require: base/graphics
@require: base/option-ext

@import: arrows

module ArrowCommands : sig

val \draw : [float?; float?; Arrow.t] math-cmd
val \xrightarrow : [float?; float?; Arrow.t; float?; math] math-cmd

end = struct

let draw pos-f len-f arr ctx =
let fs = Context.get-font-size ctx in
let pos = fs *' pos-f in
let len = fs *' len-f in
let rec = Arrow.read arr ctx in
let md = rec#metadata in
let mb = md#body in
let mt = md#tail in
let mh = md#head in
let from = (0pt, pos) in
let w0 = mb#length +' mh#length +' mt#length in
let w = Length.max len w0 in
let to = (w, pos) in
let gr-l = rec#draw from to in
let l = List.fold-right Length.min 0pt [mb#mid-left; mb#end-left; mh#left; mt#left] in
let r = List.fold-right Length.max 0pt [mb#mid-right; mb#end-right; mh#right; mt#right] in
let h = pos -' l in
let d = r -' pos in
Inline.of-graphics w h d (fun pt -> List.map (Graphics.shift pt) gr-l)

let-math \draw ?:pos-f-o ?:len-f-o arr =
let pos-f = pos-f-o |> Option.unwrap-or 0.25 in
let len-f = len-f-o |> Option.unwrap-or 1. in
text-in-math MathRel (draw pos-f len-f arr)

let label-ctx ctx = ctx |> Context.set-font-size (Context.get-font-size ctx *' 0.75)

let xrightarrow pos-f len-f arr label-pd-f label-m ctx =
let fs = Context.get-font-size ctx in
let pos = fs *' pos-f in
let len = fs *' len-f in
let label-pd = fs *' label-pd-f in
let label-gr = embed-math (label-ctx ctx) label-m |> Graphics.of-inline (0pt, 0pt) in
let rec = Arrow.read arr ctx in
let md = rec#metadata in
let mb = md#body in
let mh = md#head in
let mt = md#tail in
let ((x0, y0), (x1, y1)) = Graphics.bbox label-gr in
let body-len = Length.max (x1 -' x0) mb#length in
let (head-len, tail-len) = (
  let len0 = body-len +' mh#length +' mt#length in
  if Length.(len0 < len)
  then (
    let d = (len -' len0) *' 0.5 in
    (mh#length +' d, mt#length +' d)
  ) else (mh#length, mt#length)
) in
let w = body-len +' head-len +' tail-len in
let from = (0pt, pos) in
let to = (w, pos) in
let arr-gr-l = rec#draw from to in
let label-h = y1 -' y0 in
let l = List.fold-right Length.min 0pt [(mb#mid-left -' label-h) -' label-pd; mb#end-left; mh#left; mt#left] in
let r = List.fold-right Length.max 0pt [mb#mid-right; mb#end-right; mh#right; mt#right] in
let h = pos -' l in
let d = r -' pos in
let gr-l = arr-gr-l |> List.cons (Graphics.shift (tail-len +' body-len *' 0.5 -' (x0 +' x1) *' 0.5, (Length.neg mb#mid-left +' label-pd +' pos) -' y0) label-gr) in
Inline.of-graphics w h d (fun pt -> List.map (Graphics.shift pt) gr-l)

let-math \xrightarrow ?:pos-f-o ?:len-f-o arr ?:label-pd-f-o label-m =
let pos-f = pos-f-o |> Option.unwrap-or 0.25 in
let len-f = len-f-o |> Option.unwrap-or 1. in
let label-pd-f = label-pd-f-o |> Option.unwrap-or 0.2 in
text-in-math MathRel (xrightarrow pos-f len-f arr label-pd-f label-m)

end
