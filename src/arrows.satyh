@require: pervasives
@require: base/graphics
@require: base/path
@require: base/context
@require: base/list-ext

@import: types
@import: body
@import: head
@import: tail

module Arrow : sig

type t

val make : (context -> (|
  metadata : arrow-metadata;
  draw : point -> point -> graphics list;
|)) -> t
val read : t -> context -> (|
  metadata : arrow-metadata;
  draw : point -> point -> graphics list;
|)

val of-bth : (|
  body : ArrowBody.t;
  tail : ArrowTail.t;
  head : ArrowHead.t;
|) -> t

val line : (|
  width : float;
|) -> t
val multi-line : int -> float -> (|
  width : float;
|) -> t
val solid : (|
  line-width : float;
  head-size : float;
  head-ext : float;
|) -> t
val multi-solid : int -> float -> (|
  line-width : float;
  head-size : float;
  head-ext : float;
|) -> t
val dashed : (|
  line-width : float;
  head-size : float;
  head-ext : float;
  dash : (|
    fill : float;
    space : float;
    shift : float;
  |);
|) -> t
val tail : (|
  line-width : float;
  head-size : float;
  head-ext : float;
  tail-size : float;
  tail-ext : float;
|) -> t
val multi-head : int -> float -> (|
  line-width : float;
  head-size : float;
  head-ext : float;
|) -> t

end = struct

type t = context -> (|
  metadata : arrow-metadata;
  draw : point -> point -> graphics list;
|)

let make f = f
let read rec ctx = rec ctx

let of-bth rec ctx =
let b = ArrowBody.read rec#body ctx in
let bm = b#metadata in
let t = ArrowTail.read bm rec#tail ctx in
let tm = t#metadata in
let h = ArrowHead.read bm rec#head ctx in
let hm = h#metadata in
(|
  metadata = (|
    body = bm;
    head = hm;
    tail = tm;
  |);
  draw = fun from to -> (
    let a = Arrow-Point.(arg (to - from)) in
    let grb-l = b#draw (|head = hm; tail = tm|) from to in
    let grt-l = t#draw a |> List.map (Graphics.shift from) in
    let grh-l = h#draw a |> List.map (Graphics.shift to) in
    [grb-l; grt-l; grh-l] |> List.concat
  )
|)

let line rec = of-bth (|
  body = ArrowBody.solid rec;
  tail = ArrowTail.none;
  head = ArrowHead.none;
|)

let multi-line n d rec = of-bth (|
  body = ArrowBody.multi-solid n d rec;
  tail = ArrowTail.none;
  head = ArrowHead.none;
|)

let solid rec = of-bth (|
  body = ArrowBody.solid (|
    width = rec#line-width;
  |);
  tail = ArrowTail.none;
  head = ArrowHead.vee (|
    size = rec#head-size;
    ext = rec#head-ext;
    line-width = rec#line-width;
  |);
|)

let multi-solid n d rec = of-bth (|
  body = ArrowBody.multi-solid n d (|
    width = rec#line-width;
  |);
  tail = ArrowTail.none;
  head = ArrowHead.vee (|
    size = rec#head-size;
    ext = rec#head-ext;
    line-width = rec#line-width;
  |);
|)

let dashed rec = of-bth (|
  body = ArrowBody.dashed (|
    width = rec#line-width;
    dash = rec#dash;
  |);
  tail = ArrowTail.none;
  head = ArrowHead.vee (|
    size = rec#head-size;
    ext = rec#head-ext;
    line-width = rec#line-width;
  |);
|)

let tail rec = of-bth (|
  body = ArrowBody.solid (|
    width = rec#line-width;
  |);
  tail = ArrowTail.vee (|
    size = rec#tail-size;
    ext = rec#tail-ext;
    line-width = rec#line-width;
  |);
  head = ArrowHead.vee (|
    size = rec#head-size;
    ext = rec#head-ext;
    line-width = rec#line-width;
  |);
|)

let multi-head n d rec = of-bth (|
  body = ArrowBody.solid (|
    width = rec#line-width;
  |);
  tail = ArrowTail.none;
  head = ArrowHead.multi-vee n d (|
    size = rec#head-size;
    ext = rec#head-ext;
    line-width = rec#line-width;
  |);
|)

end
