@require: base/context
@require: base/path
@require: base/length
@require: base/list-ext
@require: base/fn
@require: base/float
@require: base/graphics

@import: types
@import: lib/point

module ArrowHead : sig

type t

val make : (arrow-body-metadata -> context -> (|
  metadata : arrow-head-metadata;
  draw : float -> graphics list;
|)) -> t
val read : arrow-body-metadata -> t -> context -> (|
  metadata : arrow-head-metadata;
  draw : float -> graphics list;
|)

val of-path : (arrow-body-metadata -> context -> (|
  metadata : arrow-head-metadata;
  path : path;
  stroke : path -> graphics;
|))-> t

val none : t
val union : t -> t -> t
val shift : bool -> float -> t ->t
val duplicate : bool -> int -> float -> t -> t

val vee : (|
  size : float;
  ext : float;
  line-width : float;
|) -> t
val multi-vee : int -> float -> (|
  size : float;
  ext : float;
  line-width : float;
|) -> t

end = struct

type t = arrow-body-metadata -> context -> (|
  metadata : arrow-head-metadata;
  draw : float -> graphics list;
|)

let make f = f
let read body rec ctx = rec body ctx

let none _ _ = (|
  metadata = (|
    left = 0pt;
    right = 0pt;
    length = 0pt;
    depth = fun _ -> 0pt;
  |);
  draw = fun _ -> [];
|)

let union head1 head2 ctx body =
let h1 = head1 ctx body in
let h2 = head2 ctx body in
let m1 = h1#metadata in
let m2 = h2#metadata in
(|
  metadata = (|
    left = Length.min m1#left m2#left;
    right = Length.max m1#right m2#right;
    length = Length.max m1#length m2#length;
    depth = fun p -> Length.max (m1#depth p) (m2#depth p);
  |);
  draw = fun a -> (
    let gr-l1 = h1#draw a in
    let gr-l2 = h2#draw a in
    List.concat [gr-l1; gr-l2]
  );
|)

let shift keep-depth p-f head body ctx =
let h = head body ctx in
let m = h#metadata in
let p = Context.get-font-size ctx *' p-f in
let np = Length.neg p in
(|
  metadata = (|
    m with
    length = m#length +' p;
    depth = (
      if keep-depth then m#depth
      else fun q -> m#depth q +' p
    );
  |);
  draw = fun a -> (
    h#draw a
    |> List.map (Graphics.shift Arrow-Point.(of-arg np a))
  );
|)

let-rec duplicate keep-depth n p-f head =
if n <= 0 then none
else (
  let h1 = duplicate keep-depth (n - 1) p-f head in
  let h2 = shift keep-depth p-f h1 in
  union head h2
)

let of-path f body ctx =
let rec = f body ctx in
(|
  metadata = rec#metadata;
  draw = fun a -> (
    let dx = Float.cos a in
    let dy = Float.sin a in
    let path = linear-transform-path dx (Float.neg dy) dy dx rec#path in
    [rec#stroke path]
  );
|)

let vee rec = of-path (fun body ctx -> (
  let fs = Context.get-font-size ctx in
  let color = Context.get-text-color ctx in
  let d1 = List.fold-right Length.max 0pt [fs *' rec#size; body#end-right; Length.neg body#end-left] in
  let d2 = fs *' rec#ext in
  let d = d1 +' d2 in
  let nd = Length.neg d in
  let path = (
    List.fold-left (Fn.flip Path.line-to) (Path.start (nd, d)) [(0pt, 0pt); (nd, nd)]
    |> Path.terminate
  ) in
  (|
    metadata = (|
      left = nd;
      right = d;
      length = d;
      depth = Length.abs;
    |);
    path = path;
    stroke = Graphics.stroke (fs *' rec#line-width) color;
  |)
))

let multi-vee n p-f rec = duplicate true n p-f (vee rec)

end
